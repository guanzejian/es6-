<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title></title>
	</head>
	<body>
		
	</body>
	<script>
		// map  \  reduce  \ filter  \  forEach
/*map*/		var arr = [25,21,89,61,88];
			var result = arr.map(item=>item>60?"及格":"不及格");
			console.log(result)

/*reduce*/   //( 临时结果， item每个数  , i 下标 )
 			var arr2 = [12,5654,556,5565];
 			var result2 = arr2.reduce((a,item,i)=>{
 				// console.log(a)
 				// console.log(item)
 				// console.log(i)
 				return (a+item)/i+1
 			})
 			console.log(result2)

 /*filter*/  
 			var arr3 = [
 				{ id:1,name:"男士内裤",price:35 },
 				{ id:2,name:"女士包",price:35000 },
 				{ id:3,name:"男士包",price:45 },
 				{ id:4,name:"女士内裤",price:12000 }
 			]
 			let result3 = arr3.filter(item=>item.price>1000)			
 			console.log(result3)

 /*forEach*/
 			var arr4 = [
 				{ id:1,name:"男士内裤",price:35 },
 				{ id:2,name:"女士包",price:35000 },
 				{ id:3,name:"男士包",price:45 },
 				{ id:4,name:"女士内裤",price:12000 }
 			];
 			let result4 = arr4.forEach((item,i)=>{
	 			console.log(item)
 			})

/* Object.entries(obj) 扁平化对象，成为二维数组 */ 

const obj = {a:1, b:2 ,c:3};
console.log(Object.entries(obj));   // [["a",1],["b",2],["c",3]];

var shuzu = [1,2,3,3,1,2,3,1,1,4,4,5];
console.log([...new Set(shuzu)])


// async 后面的函数返回一个promise 的结果， 调用时通过promise 的then 方法拿到结果
async function test(){
	return 'hello'
}
const Test = test();
console.log(Test)   // Promise { resolved: 'hello' }
Test.then(res =>{
	console.log(res)
})

// await是async wait的意思： wait的是resolve(data)的消息，并把数据data返回，比如下面代码中，
// 当Promise对象由Pending变为Resolved的时候，变量a就等于data，然后再顺序执行下面的语句console.log(a)，
// 这真的是等待，真的是顺序执行，表现和同步代码几乎一模一样；
// const a = await new Promise((resolve, reject) => {
//     // async process ...
//     return resolve(data);
// });
// console.log(a);
	</script>
</html>